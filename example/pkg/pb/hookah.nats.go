// Code generated by protoc-gen-nats 0.1.0, DO NOT EDIT.
// source: proto/hookah.proto

package pb

import context "context"
import fmt "fmt"

import nats "github.com/nats-io/nats.go"
import micro "github.com/nats-io/nats.go/micro"
import "google.golang.org/protobuf/proto"
import "google.golang.org/protobuf/reflect/protoreflect"

// Version compatibility assertion.
// If the constant is not defined in the package, that likely means
// the package needs to be updated to work with this generated code.
const _ = nats.Version

// ====================================
// UsersAndPermissionsService Interface
// ====================================

// Service will use the "example.usersandpermissionsservice" service group
type UsersAndPermissionsService interface {
	//
	// Method subject will be "example.usersandpermissionsservice.smoke"
	Smoke(context.Context, *Request) (*Response, error)
}

// ======================================
// UsersAndPermissionsService NATS Client
// ======================================

type ClientConnector interface {
	RequestWithContext(ctx context.Context, subject string, in, out protoreflect.ProtoMessage) error
	Close()
}

func NewUsersAndPermissionsServiceClient(client ClientConnector, name string) UsersAndPermissionsService {
	return &usersAndPermissionsServiceClient{
		client: client,
		name:   name,
	}
}

func (u *usersAndPermissionsServiceClient) getSubject(endpoint string) string {
	return fmt.Sprintf("%s.%s", u.name, endpoint)
}

var _ UsersAndPermissionsService = (*usersAndPermissionsServiceClient)(nil)

type usersAndPermissionsServiceClient struct {
	client ClientConnector
	name   string
}

func (impl *usersAndPermissionsServiceClient) Smoke(ctx context.Context, in *Request) (*Response, error) {
	out := new(Response)
	err := impl.client.RequestWithContext(ctx, impl.getSubject("smoke"), in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ==========================================
// UsersAndPermissionsServiceServer Interface
// ==========================================

// Service will use the "example.usersandpermissionsservice" service group
type UsersAndPermissionsServiceServer interface {
	//
	// Method subject will be "example.usersandpermissionsservice.smoke"
	Smoke(context.Context, *Request, *Response) error
}

// =================================================
// UsersAndPermissionsService Micro Service Handlers
// =================================================

type Registrar interface {
	// TODO: поменять group interface{} на type
	RegisterService(ctx context.Context, group interface{}, impl interface{}) error
	Close()
}

// NewUsersAndPermissionsServiceServer builds a new micro.Service that will be registered with the instance provided
// Each RPC on the service will be mapped to a new endpoint within the micro service
func RegisterUsersAndPermissionsServiceServer(ctx context.Context, service Registrar, impl UsersAndPermissionsServiceServer) error {
	return service.RegisterService(ctx, UsersAndPermissionsService_GroupDesc, impl)
}

func _UsersAndPermissionsService_Smoke_Handler(ctx context.Context, req micro.Request, impl interface{}) (protoreflect.ProtoMessage, error) {
	in := new(Request)
	if err := proto.Unmarshal(req.Data(), in); err != nil {
		return nil, err
	}
	out := new(Response)
	err := impl.(UsersAndPermissionsServiceServer).Smoke(ctx, in, out)
	return out, err
}

// TODO: сделать лучше
type GroupDescer interface {
	GetMethods() []interface{}
}

type GroupDesc struct {
	Methods []interface{}
}

func (g *GroupDesc) GetMethods() []interface{} {
	return g.Methods
}

// TODO: сделать лучше
type MethodDescer interface {
	GetName() string
	GetHandler() func(ctx context.Context, req micro.Request, impl interface{}) (protoreflect.ProtoMessage, error)
}

type MethodDesc struct {
	Name    string
	Handler func(ctx context.Context, req micro.Request, impl interface{}) (protoreflect.ProtoMessage, error)
}

func (m *MethodDesc) GetName() string {
	return m.Name
}

func (m *MethodDesc) GetHandler() func(ctx context.Context, req micro.Request, impl interface{}) (protoreflect.ProtoMessage, error) {
	return m.Handler
}

var UsersAndPermissionsService_GroupDesc = &GroupDesc{
	Methods: []interface{}{
		&MethodDesc{
			Name:    "smoke",
			Handler: _UsersAndPermissionsService_Smoke_Handler,
		},
	},
}

var natsFileDescriptor0 = []byte{
	// 177 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2a, 0x28, 0xca, 0x2f,
	0xc9, 0xd7, 0xcf, 0xc8, 0xcf, 0xcf, 0x4e, 0xcc, 0xd0, 0x03, 0x73, 0x84, 0xd8, 0x53, 0x2b, 0x12,
	0x73, 0x0b, 0x72, 0x52, 0x95, 0x64, 0xb9, 0xd8, 0x83, 0x52, 0x0b, 0x4b, 0x53, 0x8b, 0x4b, 0x84,
	0x84, 0xb8, 0x58, 0x32, 0x52, 0x13, 0x4b, 0x24, 0x18, 0x15, 0x18, 0x35, 0x58, 0x83, 0xc0, 0x6c,
	0x25, 0x05, 0x2e, 0x8e, 0xa0, 0xd4, 0xe2, 0x82, 0xfc, 0xbc, 0xe2, 0x54, 0x21, 0x11, 0x2e, 0xd6,
	0xb2, 0xc4, 0x9c, 0xd2, 0x54, 0x09, 0x26, 0xb0, 0x02, 0x08, 0xc7, 0xc8, 0x87, 0x4b, 0x2a, 0xb4,
	0x38, 0xb5, 0xa8, 0xd8, 0x31, 0x2f, 0x25, 0x20, 0xb5, 0x28, 0x37, 0xb3, 0xb8, 0x38, 0x33, 0x3f,
	0xaf, 0x38, 0x38, 0xb5, 0xa8, 0x2c, 0x33, 0x39, 0x55, 0x48, 0x8f, 0x8b, 0x35, 0x38, 0x37, 0x3f,
	0x3b, 0x55, 0x48, 0x40, 0x0f, 0x6a, 0xa3, 0x1e, 0xd4, 0x3a, 0x29, 0x41, 0x24, 0x11, 0x88, 0x0d,
	0x4a, 0x0c, 0x4e, 0x5c, 0x51, 0x1c, 0x7a, 0xfa, 0x05, 0xd9, 0xe9, 0xfa, 0x05, 0x49, 0x49, 0x6c,
	0x60, 0xa7, 0x1a, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x9b, 0xe8, 0x87, 0x0f, 0xc0, 0x00, 0x00,
	0x00,
}
